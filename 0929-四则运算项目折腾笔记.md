---
title: 四则运算项目折腾笔记
EnglishTitle: 0
date: 2018-09-29 21:46:14
tags:
---
[Github项目地址传送门](https://github.com/hyzgh/arithmetic-problems-generator)


# 项目相关要求
1. 使用 -n 参数控制生成题目的个数(完成)
2. 使用 -r 参数控制题目中数值（自然数、真分数和真分数分母）的范围。该参数可以设置为1或其他自然数。该参数必须给定，否则程序报错并给出帮助信息。
2. 生成的题目中计算过程不能产生负数，也就是说算术表达式中如果存在形如e1 − e2的子表达式，那么e1 ≥ e2。
4. 生成的题目中如果存在形如e1 ÷ e2的子表达式，那么其结果应是真分数。
5. 每道题目中出现的运算符个数不超过3个。
6. 程序一次运行生成的题目不能重复，即任何两道题目不能通过有限次交换+和×左右的算术表达式变换为同一道题目。例如，23 + 45 = 和45 + 23 = 是重复的题目，6 × 8 = 和8 × 6 = 也是重复的题目。3+(2+1)和1+2+3这两个题目是重复的，由于+是左结合的，1+2+3等价于(1+2)+3，也就是3+(1+2)，也就是3+(2+1)。但是1+2+3和3+2+1是不重复的两道题，因为1+2+3等价于(1+2)+3，而3+2+1等价于(3+2)+1，它们之间不能通过有限次交换变成同一个题目。生成的题目存入执行程序的当前目录下的Exercises.txt文件。
7. 在生成题目的同时，计算出所有题目的答案，并存入执行程序的当前目录下的Answers.txt文件。
8. 程序应能支持一万道题目的生成。
9. 程序支持对给定的题目文件和答案文件，判定答案中的对错并进行数量统计， 统计结果输出到文件Grade.txt。

# 效能分析
本程序主要由生成运算题目和检查答案正确性两个模块，因此效能分析也主要针对这两个模块进行。
1. 生成运算题目
生成一百万条题目时候的时间占比情况：

由上图看出了，占用时间最多的前五个函数为
  1. questionSetGenerate
  2. gcd
  3. addbrackets
  4. digToString
  5. ImproperFraction

其中，questionSetGenerate是生成运算题目的函数入口，占用时间最长。gcd是在题目运算过程，分数通分时进行调用的，具体实现是辗转相除法。addbrackets是在生成题目的过程给表达式添加括号。digTostring是在生成题目的过程将数字转化为字符串。ImproperFraction是真分数的类名，由于生成的表达式中普遍含有真分数，所以多次调用了它的构造函数。

2. 检查答案正确性
检查五十万条题目时的时间占比情况：


由上图可以看出，占用时间最多的前五个函数中，有
  1. gcd
  2. stringToImproperFraction
  3. __deque_buf_size
  4. transformInfixExprToSuffixExpr
  5. _Deque_base

其中，gcd用于运算过程的通分，stringToImproperFraction用于将字符串转化为真分数， transformInfixExprToSuffixExpr用于将中缀表达式转化为后缀表达式。另外两个函数是系统函数。

因此，假如要优化效能的话，可以优先在源代码追踪一下上述函数，看能否减少这些函数的调用或者优化其实现方式。

# 思路


# 具体设计&关键代码
## ImproperFraction类
构建一个ImproperFraction的类，然后重载这个类的四种运算 **+-x÷** 以及以及六种逻辑关系**'<'  '=='  '<='  '!='  '>'  '>='**判断，在后续的代码编写之中都是基于这个类进行运算

##### 核心代码如下：

```c++

	class ImproperFraction {
	 public :
	  ImproperFraction(){}
	  ImproperFraction (int Mole, int Deno, int Coef = 0) {
	    int g = std::__gcd (Mole, Deno);
	    g = std::max(g, 1);
	    mole = (Mole + Coef * Deno) / g;
	    deno = Deno / g;
	  }
	  ImproperFraction operator + (const ImproperFraction & rhs ) const {
	    int DENO = deno * rhs.deno;
	    int MOLE = mole * rhs.deno + rhs.mole * deno;
	    ImproperFraction res = ImproperFraction (MOLE, DENO);
	    return res;
	  }
	  ImproperFraction operator - (const ImproperFraction & rhs ) const {
	    int DENO = deno * rhs.deno;
	    int MOLE = mole * rhs.deno - rhs.mole * deno;
	    ImproperFraction res = ImproperFraction (MOLE, DENO);
	    return res;
	  }
	  ImproperFraction operator * (const ImproperFraction & rhs ) const {
	    int DENO = deno * rhs.deno;
	    int MOLE = mole * rhs.mole;
	    ImproperFraction res = ImproperFraction (MOLE, DENO);
	    return res;
	  }
	  ImproperFraction operator / (const ImproperFraction & rhs ) const {
	    int DENO = deno * rhs.mole;
	    int MOLE = mole * rhs.deno;
	    ImproperFraction res = ImproperFraction (MOLE, DENO);
	    return res;
	  }
	  bool operator < (const ImproperFraction & rhs ) const {
	    return mole * rhs.deno < rhs.mole * deno;
	  }
	  bool operator == (const ImproperFraction & rhs ) const {
	    return mole * rhs.deno == rhs.mole * deno;
	  }
	  bool operator != (const ImproperFraction & rhs ) const {
	    return !(mole * rhs.deno == rhs.mole * deno);
	  }
	  bool operator <= (const ImproperFraction & rhs ) const {
	    return (*this) < rhs || (*this) == rhs;
	  }
	  bool operator > (const ImproperFraction & rhs ) const {
	    return !((*this) <= rhs);
	  }
	  bool operator >= (const ImproperFraction & rhs ) const {
	    return (*this) > rhs || (*this) == rhs;
	  }
	
	 private :
	  int mole = 0; // 分子
	  int deno = 1; // 分母 
	};
```
## 题集的生成
##### 表达式的生成：
在这里选择的是rand() 随机生成 运算符个数，类型以及每个被运算的  	数值。
##### 表达式的合法性判断：
 在生成过程之中，有两个要点会导致表达式非法
1.运算过程中出现负值
2.在÷运算后面出现0

解决办法：
两个特殊判断即可
  
##### 表达式的去重：
表达式的重复有两种情况:
1.完完全全的重复，如出现两个1 + 2 + 3 的表达式
2.运算顺序上的重复，如:
>###### 1 + 2 + 3 和 2 + 1 + 3重复
>###### 2 + 3 x 4 和 4 x 3 + 2重复
                             
解决办法：
对于(1)的情况只需要将生成的表达式保存进C++STL的set之中即可自动去重。
对于(2)的情况，则是按照一定规则生成表达式来避免这一情况，规则如下：
>###### 1.默认左边的运算符的优先度高于右边
>###### 2.第一个数字一定不小于第二个数值
因此1 + 2 + 3和2 + 3 x 4不会被生成，而只会生成2 + 1 + 3和4 x 3 + 2
  
 ##### 题集无法生成要求的数量：
 例如：
传入的参数是 -n 10000 -r 1 的时候，很明显无法生成10000道题目，因此陷入死循环的生成中

解决方案：
设置一个时间戳time，当生成表达式的部分循环了1000000次之后自动跳出循环，终止生成表达式 
  
 ##### 答案的生成：
 在表的是合法性判断的时候，会判断最终的数值是否小于0，在这里就已经计算标准答案，保存并打印到answer.txt即可
##### 核心代码如下：

``` C++

	void questionSetGenerate (int limit, int number) {
	  std::set<std::string>expressions;
	  std::vector<std::string>exercise;
	  std::vector<ImproperFraction>answer;
	  ImproperFraction zero = ImproperFraction(0, 1);
	  int time = 0;
	  while (expressions.size() < number && time < 1000000) {
	    time ++;
	    int sz = expressions.size();
	    int opnumber = rand() % 3 + 1;
	    ImproperFraction a[5];
	    ImproperFraction res = ImproperFraction(0, 1);
	    const ImproperFraction zero = ImproperFraction(0, 1);
	    char op[4];
	    
	    for (int i = 0; i <= opnumber; i++) {
	      a[i] = ImproperFraction(rand() % (limit * limit), std::max(1, rand() % limit));
	      if (i) {
	        op[i] = oper[rand() % 4];
	      }
	    }
	    std::string exp = "";
	    bool flag = true;
	    if (a[0] < a[1]) {
	      std::swap (a[0], a[1]);
	    }
	
	    for (int i = 0; i <= opnumber; i++) {
	      if (i) {
	        if (op[i] == '+') {
	          res = res + a[i];
	        } else if (op[i] == '*') {
	          res = res * a[i];
	        } else if (op[i] == '-') {
	          res = res - a[i];
	        } else {
	          if (a[i] == zero) {
	            flag = false;
	            break;
	          }
	          res = res / a[i];
	        }
	        exp = exp + ' ';
	        exp = exp + op[i];
	        exp = exp + ' ';
	      } else {
	        res = res + a[i];
	      }
	      fractionToString(a[i], exp);
	      if (res < zero) {
	        flag = false;
	        break;
	      }
	    }
	    if (flag) {
	      expressions.insert(exp);
	      if (expressions.size() > sz) {
	        exercise.push_back(addbrackets(exp));
	        answer.push_back(res);
	      }
	    }
	  }
	}

```

## 答案正确性的检测
用户通过参数-e exercises.txt -a answers.txt，传进来了题目文件的名称和答案文件的名称。
首先，由于文件可能不存在或者没有访问的权限，我们需要对此进行检查，假如有错误，则进行报错，没有异常才进行下一步。
第二步，我们需要对exercises.txt文件中的题目计算一遍，然后再和answers.txt文件中的答案进行比较。题目的计算分两步进行，即先将中缀表达式转化为后缀表达式，然后计算后缀表达式的答案。
对于这个函数，我们考虑了exercises.txt行数和answers.txt行数不相等的情况，此时我们将以exercises.txt的行数为准，假如answers.txt行数过少，那么将视为错误答案，假如过多，那么将被忽略。
```c++
// 检查答案
void checkAnswer(FILE *exerciseFile, FILE *answerFile) {
  FILE *pFile = getPointerToGradeFile();
  int problemID = 0;
  char answer[256];
  char exercise[256];
  std::vector<int> wrongID;
  std::vector<int> correctID;
  // 答案的行数可能不等于题目的行数
  while (fgets(answer, 256, answerFile)) {
    if (!fgets(exercise, 256, exerciseFile)) {
      break;
    }
    problemID++;
    removeRedundantPart(answer, exercise);
    handleDivideEncoding(exercise);

    if (getInfixExpressionAnswer(exercise) == stringToImproperFraction(answer)
       ) {
      correctID.push_back(problemID);
    } else {
      wrongID.push_back(problemID);
    }
  }
  while (fgets(exercise, 256, exerciseFile)) {
    problemID++;
    wrongID.push_back(problemID);
  }

  printID(pFile, const_cast<char*>("Correct"), correctID);
  printID(pFile, const_cast<char*>("Wrong"), wrongID);
  fclose(pFile);
  printf("Check answer done!\n");
}

```

# 测试报告



# 代码覆盖率


# PSP
| PSP2.1                                  | Personal Software Process Stages        | 预估耗时（分钟） | 实际耗时（分钟） |
|-----------------------------------------|-----------------------------------------|------------------|------------------|
| Planning                                | 计划                                    |25                  |50                |
| · Estimate                              | · 估计这个任务需要多少时间              |25               |50              |
| Development                             | 开发                                    |525                  |600              |
| · Analysis                              | · 需求分析 (包括学习新技术)             |75               |75                  |
| · Design Spec                           | · 生成设计文档                          |25              |0                  |
| · Design Review                         | · 设计复审 (和同事审核设计文档)         |0              |0                |
| · Coding Standard                       | · 代码规范 (为目前的开发制定合适的规范) |25              |0                |
| · Design                                | · 具体设计                              |25                |50                |
| · Coding                                | · 具体编码                              |325               |425                  |
| · Code Review                           | · 代码复审                              |25                  |25                  |
| · Test                                  | · 测试（自我测试，修改代码，提交修改）  |25                  |25                  |
| Reporting                               | 报告                                    |100              |100                  |
| · Test Report                           | · 测试报告                              |50                  |50                  |
| · Size Measurement                      | · 计算工作量                            |25                  |25                  |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划          |25                  |25                  |
| 合计                                    |                                         |650                  |750                  |

# 项目小结


